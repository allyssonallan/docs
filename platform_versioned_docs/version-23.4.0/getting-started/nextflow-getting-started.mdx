---
title: "Get started with Nextflow"
description: "An overview and getting started guide for new users of Nextflow."
date: "14 May 2024"
tags: [nextflow, getting started, get started]
---

The Nextflow scripting language is an extension of the Groovy programming language. Nextflow lets you run analysis pipelines on virtually any computing environment. From version `22.03.0-edge` DSL2 became the default DSL version. If you're still using DSL1, the [migrating from DSL1 page](https://www.nextflow.io/docs/latest/dsl1.html) should be read before you proceed.

Nextflow is a workflow framework that can be used in a wide range of applications to integrate different shell commands as individual processes in one cohesive pipeline that's portable, reproducible, scalable, and checkpointed. 

Processes run locally by default. This works well for pipeline development, testing, and small-scale workflows. For large-scale computational pipelines, a High-Performance Computing (HPC) cluster or cloud platform is recommended.

- [I'm completely new. What is Nextflow?](#nextflow-overview)
- I want to install and run Nextflow for the first time (#install-nextflow)
- I want to run a pipeline (link to pipeline section)
- I'm advanced - take me to the [reference documentation](https://www.nextflow.io/docs/latest/overview.html).

### Install Nextflow

Install Nextflow locally, or run it [in a container](https://training.nextflow.io/basic_training/containers/). You can also try Nextflow in the [Gitpod training environment](https://gitpod.io/#https://github.com/nextflow-io/training) before installing it on your machine.

#### Download Nextflow

Open your terminal and execute this command:

```
wget -qO- https://get.nextflow.io | bash
``` 

Alternatively, you could use the curl command:

```
curl -s https://get.nextflow.io | bash
```

Next, ensure that the downloaded binary is executable:

```
chmod +x nextflow
```

Finally, ensure the Nextflow executable is in your `$PATH`. The executable could be in `/usr/local/bin`, `/bin/`, etc.

### Check your installation

Check that you have correctly installed nextflow by running the following command:

```
nextflow info
```

**Display Nextflow runtime and system info**

```
nextflow info

  Version: 20.07.1 build 5412
  Created: 24-07-2020 15:18 UTC (20:48 IDT)
  System: Mac OS X 10.15.6
  Runtime: Groovy 2.5.11 on OpenJDK 64-Bit Server VM 1.8.0_192-b01
  Encoding: UTF-8 (UTF-8)
```

**Display information about a specific project**

```
nextflow info nextflow-io/hello

  project name: nextflow-io/hello
  repository  : https://github.com/nextflow-io/hello
  local path  : /Users/evanfloden/.nextflow/assets/nextflow-io/hello
  main script : main.nf
  revisions   :
  * master (default)
    mybranch
    testing
    v1.1 [t]
    v1.2 [t]
```

## Processes and channels

In practice, a Nextflow pipeline script is made by joining individual processes together. A process can be written in any scripting language that the Linux platform can execute (Bash, Perl, Ruby, Python, etc.).

Processes are executed independently and are isolated from each other, so they do not share a common (writable) state. Processes communicate via asynchronous FIFO (first in, first out) queues, called _channels_ in Nextflow.

- Any process can define one or more channels as inputs and outputs. Channels are then used to manipulate data flow from one process to the next.
- The interaction between these processes, and ultimately the pipeline execution flow itself, is implicitly defined by these input and output declarations.
- A process may contain any of the following definition blocks: directives, inputs, outputs, `when` clause, and the `process` script.

The syntax is defined as follows:

```
process < name > {

  [ directives ]

  input:
    < process inputs >

  output:
    < process outputs >

  when:
    < condition >

  [script|shell|exec]:
    < user script to be executed >

}
```

A channel has two major properties:

- Sending a message is an asynchronous (non-blocking) operation — the sender doesn't have to wait for the receiving process.
- Receiving a message is a synchronous (blocking) operation — the receiving process must wait until a message has arrived.

Nextflow defines two types of channels: queue channels and value channels. The difference between queue and value channels is relevant for processes with multiple input channels.

- Queue channels are collections of items that can contain many elements, but each element is consumed after it is used. A queue channel can be created by factory methods ([of](https://www.nextflow.io/docs/latest/channel.html#of), [fromPath](https://www.nextflow.io/docs/latest/channel.html#frompath), etc), operators ([map](https://www.nextflow.io/docs/latest/operator.html#operator-map), [flatMap](https://www.nextflow.io/docs/latest/operator.html#operator-flatmap), etc), and [processes](https://www.nextflow.io/docs/latest/process.html#process-output).
- Value channels are collections of a single item that can be reused in different processes. A value channel can be bound (i.e. assigned) with only one value, and consumed any number of times by a process or an operator. A value channel can be created with the value factory method or by any operator that produces a single value (first, collect, reduce, etc). A process will also emit value channels if it is invoked with all value channels, including simple values which are implicitly wrapped in a value channel.

Lastly, Nextflow operators are methods that allow you to manipulate channels. Every operator, with the exception of `set` and `subscribe`, produces one or more new channels, allowing you to chain operators to fit your needs. The Nextflow reference documentation has a [list of operators](https://www.nextflow.io/docs/latest/operator.html).

The interaction between processes, and ultimately the pipeline execution flow itself, is then explicitly defined in a workflow. In Nextflow, a workflow is a composition of processes and dataflow logic (channels and operators). The workflow definition starts with the keyword `workflow`. Workflows include an optional name, followed by the workflow body, delimited by curly braces. Workflows are lazily executed, which means that Nextflow parses the entire workflow structure first, and then executes the entire workflow at once. The order in which a task is executed is determined only by its dependencies, so a task will be executed as soon as all of its required inputs are available.

The syntax of a workflow is defined as follows:

```groovy
workflow [ name ] {

    take:
    < workflow inputs >

    main:
    < dataflow statements >

    emit:
    < workflow outputs >

}
```

Visit the [Nextflow workflow reference material](https://www.nextflow.io/docs/latest/workflow.html) for more examples of workflows.

A Nextflow script looks like this:

```groovy
// Script parameters
params.query = "/some/data/sample.fa"
params.db = "/some/path/pdb"

process blastSearch {
  input:
  path query
  path db

  output:
  path "top_hits.txt"

  """
  blastp -db $db -query $query -outfmt 6 > blast_result
  cat blast_result | head -n 10 | cut -f 2 > top_hits.txt
  """
}

process extractTopHits {
  input:
  path top_hits
  path db

  output:
  path "sequences.txt"

  """
  blastdbcmd -db $db -entry_batch $top_hits > sequences.txt
  """
}

workflow {
  def query_ch = Channel.fromPath(params.query)
  blastSearch(query_ch, params.db)
  extractTopHits(blastSearch.out, params.db).view()
}
```

The above example defines two processes. Their execution order is not determined by the fact that the `blastSearch` process comes before `extractTopHits` in the script (it could also be written the other way around). Instead, execution order is determined by their _dependencies_ -- `extractTopHits` depends on the output of `blastSearch`, so `blastSearch` will be executed first, and then `extractTopHits`.

When the workflow is started, it will create two processes and one channel (`query_ch`) and it will link all of them. Both processes will be started at the same time and they will listen to their respective input channels. Whenever `blastSearch` emits a value, `extractTopHits` will receive it (i.e. `extractTopHits` consumes the channel in a *reactive* way).

## Nextflow overview

Nextflow enables scalable and reproducible scientific workflows using software containers. It allows the adaptation of pipelines written in the most common scripting languages. Its fluent DSL simplifies the implementation and the deployment of complex parallel and reactive workflows on clouds and clusters. The Nextflow language is inspired by [the Unix philosophy](https://en.wikipedia.org/wiki/Unix_philosophy), in which many simple command line tools can be chained together into increasingly complex tasks. Similarly, a Nextflow script consists of composing many simple processes into increasingly complex pipelines. Each process executes a given tool or scripting language, and by specifying the process inputs and outputs, Nextflow coordinates the execution of tasks for you. Nextflow can execute any piece of Groovy code or use any library for the JVM platform. Each process can be written in any scripting language that can be executed by the Linux platform (Bash, Perl, Ruby, Python, etc.). The Nextflow syntax has been specialized to ease the writing of computational pipelines in a declarative manner. In practice a Nextflow pipeline script is made by joining together different processes. 

The rise of big data has made it increasingly necessary to be able to analyze and perform experiments on large datasets in a portable and reproducible manner. Parallelization and distributed computing are the best ways to tackle this challenge, but the tools commonly available to computational scientists often lack good support for these techniques, or they provide a model that fits poorly with the needs of computational scientists and often require knowledge of complex tools and APIs. Nextflow was created to address these challenges. The Nextflow runtime integrates with many popular execution platforms (HPC schedulers, cloud providers) and software tools (Git, Docker, Conda), allowing you to fully describe a computational pipeline with all of its dependencies and run it in nearly any environment -- write once, run anywhere.

Ready to get started running pipelines? The [Nextflow reference documentation](https://www.nextflow.io/docs/latest/cli.html) is a good place to start. 

### Implementation patterns

This advanced documentation discusses recurring patterns in Nextflow and solutions to many common implementation requirements. Code examples are available with notes to follow along and a GitHub repository. A curated list of Nextflow implementation patterns can be found here [https://nextflow-io.github.io/patterns/index.html](https://nextflow-io.github.io/patterns/index.html).

### Pipelines

A collection of Nextflow pipelines compiled by various contributors to the open source Nextflow project can be found here [https://github.com/nextflow-io/awesome-nextflow](https://github.com/nextflow-io/awesome-nextflow). There are also pipeline examples available [here](https://www.nextflow.io/example1.html).

### How to run a pipeline

Nextflow provides a powerful way to develop pipelines. However, it does not provide standards for how pipelines should be developed. This gap has led to the establishment of pipeline registries, such as [nf-core](https://nf-co.re/), with tools and implementation guidelines that provide support and standards for pipeline development. Nextflow works best when you have an active internet connection, as it is able to fetch all pipeline requirements. Nextflow provides a robust command line interface for the management and execution pipelines. 

If you're new to running pipelines, this [Nextflow hands-on training workshop](https://training.nextflow.io/hands_on/02_workflow/#pipeline-steps) is a good place to start. You can also take a look at [Creating a pipeline](https://nf-co.re/docs/tutorials/adding_a_pipeline/creating_a_pipeline) in the nf-core tutorials.

## Tips and tricks

- Hyphens matter! Core Nextflow command-line options use one (-), whereas pipeline-specific parameters use two (--).
- Specify `--email your@email.com` to receive emails when your pipeline completes (requires [Nextflow mail and notification configuration](https://www.nextflow.io/docs/latest/mail.html)).
- Specify `--hook_url YOUR-HOOK-URL` or set the `params.hook_url` in `nextflow.config` to receive notifications from your pipeline in Microsoft Teams or Slack. 
- Include `-r <version-number>` when running your pipeline to specify a release version explicitly. That way, the same command will give identical results in future.
- Use `-resume` to restart pipelines that did not complete. This ensures that successful tasks from the previous run won’t be re-executed.
- Use `nextflow log` to find names of all previous runs in your directory. These can be used with `-resume` to restart specific runs.
- Utilize multiple Nextflow configuration locations to your benefit. For example, use `-profile` for your cluster configuration, `~/.nextflow/config` for your personal configuration (with `params.email`, for example), and a working directory `nextflow.config` file for reproducible run-specific configuration.
- If you use Singularity, we recommend that you specify a cache directory with the nextflow environment variable `NXF_SINGULARITY_CACHEDIR` in your `~./bash_profile` or `~/.bashrc` during the installation. This will store all your container images in one place, rather than downloading an image each time you run a pipeline. Only the base directory needs to be specified, Nextflow handles the folders and file names for you.

## Troubleshooting and errors

You can find a searchable database of troubleshooting and errors on the nf-core [Troubleshooting](https://nf-co.re/docs/usage/troubleshooting/overview) page. There's also the [Nextflow community forum](https://community.seqera.io/c/nextflow/5) and the [Nextflow Slack workspace](https://www.nextflow.io/slack-invite.html).
