---
title: "Get started with Nextflow"
description: "An overview and getting started guide for new users of Nextflow."
date: "14 May 2024"
tags: [nextflow, getting started, get started]
---

Nextflow is a workflow framework that can be used by bioinformaticians to integrate different shell commands into one cohesive pipeline thatâ€™s portable, reproducible, scalable and checkpointed. 

Unless otherwise indicated, processes are run locally. This works well for pipeline development, testing, and small-scale workflows, but for large-scale computational pipelines, a High Performance Cluster (HPC) or Cloud platform is recommended.
What's your goal?

- [I'm really new to Nextflow. What's it about?](#nextflow-overview)
- I want to install and run Nextflow for the first time (link to first-run section)
- I want to run a pipeline (link to pipeline section)
- I'm advanced - take me to the reference documentation.

## Nextflow overview

The Nextflow scripting language is an extension of the Groovy programming language. Nextflow lets you run analysis pipelines on virtually any computing environment. 

Nextflow can execute any piece of Groovy code or use any library for the JVM platform. Each process can be written in any scripting language that can be executed by the Linux platform (Bash, Perl, Ruby, Python, etc.). The Nextflow syntax has been specialized to ease the writing of computational pipelines in a declarative manner. In practice a Nextflow pipeline script is made by joining together different processes. 

The rise of big data has made it increasingly necessary to be able to analyze and perform experiments on large datasets in a portable and reproducible manner. Parallelization and distributed computing are the best ways to tackle this challenge, but the tools commonly available to computational scientists often lack good support for these techniques, or they provide a model that fits poorly with the needs of computational scientists and often require knowledge of complex tools and APIs. Nextflow was created to address these challenges.

The Nextflow language is inspired by [the Unix philosophy](https://en.wikipedia.org/wiki/Unix_philosophy), in which many simple command line tools can be chained together into increasingly complex tasks. Similarly, a Nextflow script consists of composing many simple processes into increasingly complex pipelines. Each process executes a given tool or scripting language, and by specifying the process inputs and outputs, Nextflow coordinates the execution of tasks for you.

The Nextflow runtime integrates with many popular execution platforms (HPC schedulers, cloud providers) and software tools (Git, Docker, Conda), allowing you to fully describe a computational pipeline with all of its dependencies and run it in nearly any environment -- write once, run anywhere.

## Processes and channels

In practice a Nextflow pipeline script is made by joining together different processes. Each process can be written in any scripting language that can be executed by the Linux platform (Bash, Perl, Ruby, Python, etc.).

Processes are executed independently and are isolated from each other, i.e. they do not share a common (writable) state. The only way they can communicate is via asynchronous FIFO queues, called *channels* in Nextflow.

- Any process can define one or more channels as input and output. Channels are then used to manipulate the flow of data from one process to the next.
- The interaction between these processes, and ultimately the pipeline execution flow itself, is implicitly defined by these input and output declarations.
- A process may contain any of the following definition blocks: directives, inputs, outputs, when clause, and the process script. 

The syntax is defined as follows:

```
process < name > {

  [ directives ]

  input:
    < process inputs >

  output:
    < process outputs >

  when:
    < condition >

  [script|shell|exec]:
    < user script to be executed >

}
```

A channel has two major properties:

- Sending a message is an asynchronous (i.e. non-blocking) operation, which means the sender doesn't have to wait for the receiving process.
- Receiving a message is a synchronous (i.e. blocking) operation, which means the receiving process must wait until a message has arrived.

In Nextflow there are two kinds of channels: queue channels and value channels. The difference between queue and value channels is relevant for processes with multiple input channels.

- Queue channels are collections of items that can contain many elements but each of these elements are consumed after they are used. A queue channel can be created by factory methods (of, fromPath, etc), operators (map, flatMap, etc), and processes (see Process outputs).
- Value channels are collections of a single item that can be used over and over again in different processes. A value channel can be bound (i.e. assigned) with one and only one value, and can be consumed any number of times by a process or an operator. A value channel can be created with the value factory method or by any operator that produces a single value (first, collect, reduce, etc). Additionally, a process will emit value channels if it is invoked with all value channels, including simple values which are implicitly wrapped in a value channel.

Lastly, Nextflow operators are methods that allow you to manipulate channels. Every operator, with the exception of `set` and `subscribe`, produces one or more new channels, allowing you to chain operators to fit your needs. The Nextflow reference documentation has a list of operators.

The interaction between processes, and ultimately the pipeline execution flow itself, is then explicitly defined in a workflow.

In Nextflow, a workflow is a composition of processes and dataflow logic (i.e. channels and operators). The workflow definition starts with the keyword workflow, followed by an optional name, and finally the workflow body delimited by curly braces. 

A basic workflow looks like the following example: workflow

## include example 

A Nextflow script looks like this:

```groovy
// Script parameters
params.query = "/some/data/sample.fa"
params.db = "/some/path/pdb"

process blastSearch {
  input:
  path query
  path db

  output:
  path "top_hits.txt"

  """
  blastp -db $db -query $query -outfmt 6 > blast_result
  cat blast_result | head -n 10 | cut -f 2 > top_hits.txt
  """
}

process extractTopHits {
  input:
  path top_hits
  path db

  output:
  path "sequences.txt"

  """
  blastdbcmd -db $db -entry_batch $top_hits > sequences.txt
  """
}

workflow {
  def query_ch = Channel.fromPath(params.query)
  blastSearch(query_ch, params.db)
  extractTopHits(blastSearch.out, params.db).view()
}
```

The above example defines two processes. Their execution order is not determined by the fact that the `blastSearch` process comes before `extractTopHits` in the script (it could also be written the other way around). Instead, execution order is determined by their _dependencies_ -- `extractTopHits` depends on the output of `blastSearch`, so `blastSearch` will be executed first, and then `extractTopHits`.

When the workflow is started, it will create two processes and one channel (`query_ch`) and it will link all of them. Both processes will be started at the same time and they will listen to their respective input channels. Whenever `blastSearch` emits a value, `extractTopHits` will receive it (i.e. `extractTopHits` consumes the channel in a *reactive* way).

### Install Nextflow

You can install Nextflow locally, or run it [in a container](https://training.nextflow.io/basic_training/containers/). Another option is to try Nextflow out in the [Nextflow Gitpod training environment](https://gitpod.io/#https://github.com/nextflow-io/training) before ever installing anything on your own machine.

#### Download Nextflow

Open your terminal and execute this command:

```
wget -qO- https://get.nextflow.io | bash
``` 

Alternatively, you could use the curl command:

```
curl -s https://get.nextflow.io | bash
```

Next, ensure that the downloaded binary is executable:

```
chmod +x nextflow
```

Finally, ensure the Nextflow executable is in your `$PATH`. The executable could be in `/usr/local/bin`, `/bin/`, etc.

### Check your installation

Check that you have correctly installed nextflow by running the following command:

```
nextflow info
```

**Display Nextflow runtime and system info**

```
nextflow info

  Version: 20.07.1 build 5412
  Created: 24-07-2020 15:18 UTC (20:48 IDT)
  System: Mac OS X 10.15.6
  Runtime: Groovy 2.5.11 on OpenJDK 64-Bit Server VM 1.8.0_192-b01
  Encoding: UTF-8 (UTF-8)
```

**Display information about a specific project**

```
nextflow info nextflow-io/hello

  project name: nextflow-io/hello
  repository  : https://github.com/nextflow-io/hello
  local path  : /Users/evanfloden/.nextflow/assets/nextflow-io/hello
  main script : main.nf
  revisions   :
  * master (default)
    mybranch
    testing
    v1.1 [t]
    v1.2 [t]
```

## Use Nextflow

Ready to get started running pipelines. The [Nextflow reference documentation](https://www.nextflow.io/docs/latest/cli.html) is a good place to start: 

### Implementation patterns

This advanced documentation discusses recurring patterns in Nextflow and solutions to many common implementation requirements. Code examples are available with notes to follow along and a GitHub repository. A curated list of Nextflow implementation patterns can be found here [https://nextflow-io.github.io/patterns/index.html](https://nextflow-io.github.io/patterns/index.html).

### Pipelines

A collection of awesome Nextflow pipelines compiled by various contributors to the open-source Nextflow project can be found here [https://github.com/nextflow-io/awesome-nextflow](https://github.com/nextflow-io/awesome-nextflow).

### How to run a pipeline

Nextflow provides a powerful way to develop pipelines. However, it does not provide standards for how pipelines should be developed. This gap has led to the establishment of pipeline registries, such as [nf-core](https://nf-co.re/), with tools and implementation guidelines that provide support and standards for pipeline development. Nextflow works best when you have an active internet connection, as it is able to fetch all pipeline requirements. Nextflow provides a robust command line interface for the management and execution pipelines. 

If you're new to running pipelines, this [Nextflow hands-on training workshop](https://training.nextflow.io/hands_on/02_workflow/#pipeline-steps) is a good place to start.

## Tips and tricks

- Hyphens matter! Core Nextflow command-line options use one (-), whereas pipeline-specific parameters use two (--).
- Specify `--email your@email.com` to receive emails when your pipeline completes (requires [Nextflow mail and notification configuration](https://www.nextflow.io/docs/latest/mail.html)).
- Specify `--hook_url YOUR-HOOK-URL` or set the `params.hook_url` in `nextflow.config` to receive notifications from your pipeline in Microsoft Teams or Slack. 
- Include `-r <version-number>` when running your pipeline to specify a release version explicitly. That way, the same command will give identical results in future.
- Use `-resume` to restart pipelines that did not complete. This ensures that successful tasks from the previous run wonâ€™t be re-executed.
- Use `nextflow log` to find names of all previous runs in your directory. These can be used with `-resume` to restart specific runs.
- Utilize multiple Nextflow configuration locations to your benefit. For example, use `-profile` for your cluster configuration, `~/.nextflow/config` for your personal configuration (with `params.email`, for example), and a working directory `nextflow.config` file for reproducible run-specific configuration.
- If you use Singularity, we recommend that you specify a cache directory with the nextflow environment variable `NXF_SINGULARITY_CACHEDIR` in your `~./bash_profile` or `~/.bashrc` during the installation. This will store all your container images in one place, rather than downloading an image each time you run a pipeline. Only the base directory needs to be specified, Nextflow handles the folders and file names for you.

## Troubleshooting and errors
