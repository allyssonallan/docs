#DELETE THIS

apiVersion: v1
kind: ConfigMap
metadata:
  name: connect-proxy-config
  labels:
    app.kubernetes.io/component: tower-connect-proxy
data:
  Caddyfile: |
    {
        admin      off
        auto_https off
        http_port  {$CONNECT_HTTP_PORT:80}
    
        order connectauth before basicauth
        connect {
            redis_address         {$REDIS_SERVER}
            redis_password        {$REDIS_PASSWORD}
            redis_user            {$REDIS_USER}
            redis_db              {$REDIS_DB:0}
            redis_tls_enable      {$REDIS_TLS_ENABLE:false}
            redis_tls_key_file    {$REDIS_TLS_KEY_FILE:}
            redis_tls_cert_file   {$REDIS_TLS_CERT_FILE:}
            redis_tls_skip_verify {$REDIS_TLS_SKIP_VERIFY}
            redis_prefix          "{$REDIS_PREFIX:connect:session}"
            local_cache_ttl       "{$LOCAL_CACHE_TTL:2m}"
    
            studio_provider {
                client_name          "{$CONNECT_CLIENT_NAME:tower-connect-proxy-client}"
                base_url             "{$TOWER_BASE_URL}"
                redirect_uri         "https://connect.{$TOWER_CONNECT_DOMAIN}/connect_auth_callback"
                grant_type           "authorization_code"
                initial_access_token "{$INITIAL_ACCESS_TOKEN}"
            }
        }
        log {
            output stdout
            format console
            level  INFO
        }
    }

    :{$CONNECT_HTTP_PORT:80} {

      @healthcheck expression header({'User-Agent': 'ELB-HealthChecker/2.0'})
      skip_log @healthcheck
      respond @healthcheck 200
      respond 503
    }

    connect.{$TOWER_CONNECT_DOMAIN}:{$CONNECT_HTTP_PORT:80} {
      connectauth
      reverse_proxy {$TOWER_CONNECT_TUNNEL}
    }


    *.{$TOWER_CONNECT_DOMAIN}:{$CONNECT_HTTP_PORT:80} {
      connectauth
      header Access-Control-Allow-Origin      "{$TOWER_BASE_URL}"
      header Access-Control-Allow-Credentials true
      header Access-Control-Allow-Methods     "OPTIONS,HEAD,GET,POST,PUT,PATCH,DELETE"
      reverse_proxy {
          dynamic connect
          
          @unavailable status 503
          handle_response @unavailable {
            reverse_proxy {
              # try once more invalidating the local session cache
              # to sync with redis
              dynamic connect invalidate_cache
            }
          }
      }
       header {
        # Adds the Content-Security-Policy header to allow being browsed through an iframe
        # We default to the minimal needed CSP header if upstream doesn't produce the header
        # and we regex replace upstream provided header otherwise, so that we don't overwrite 
        # other security settings.
    
        ?Content-Security-Policy "frame-ancestors {$TOWER_BASE_URL} 'self'"
        >Content-Security-Policy "(.*)frame-ancestors (.*)" "$1 frame-ancestors {$TOWER_BASE_URL} 'self' $2"
      }
    }